{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/util/get-response-body.util.js","../../src/util/noop.util.js","../../src/index.js","services/services.config.js","services/generate-url-query-string.util.js","services/users.service.js","store/actions/user-list.actions.js","store/actions/selected-user.actions.js","components/UserListItem.component.js","components/UserList.component.js","App.js","store/reducers/user-list.reducer.js","store/reducers/selected-user.reducer.js","store/reducers/root.reducer.js","store/index.js","index.js"],"names":["Symbol","iterator","asyncIterator","noop","noopThunk","DEFAULT_OPTIONS","onServiceStartAction","onErrorAction","onFinallyAction","responseBodyDataKey","generateReqError","Error","resp","serviceMethodThunk","resultAction","options","error","dispatch","body","finalizer","result","e","then","bind","recover","Headers","MimeTypes","getResponseBody","setStatePromise","respBody","console","CONTENT_TYPE","ACCEPT","APPLICATION_JSON","Application","JSON","DEFAULT_SERVICE_HEADERS","generateUrlQueryString","searchParams","URLSearchParams","serviceBaseUri","getUsers","a","fetch","headers","getUserById","id","userListSetState","list","type","setSelectedUser","user","UserListItem","useDispatch","avatar","fullName","email","ListItem","ListItemAvatar","Avatar","alt","src","ListItemText","primary","Link","href","onClick","ev","preventDefault","serviceDispatcher","fetchSelectedUser","secondary","Typography","component","variant","UserList","userList","useSelector","useEffect","fetchUserList","p","l","length","Paper","List","map","key","SelectedUser","selectedUser","birthDate","streetAddress","streetSuffix","city","state","zip","Card","CardHeader","title","subheader","action","IconButton","CardContent","birthday","ageDifMs","Date","now","ageDate","Math","abs","getUTCFullYear","calculateAge","fontWeight","useAppStyles","makeStyles","theme","root","margin","spacing","App","classes","Box","className","Grid","container","item","xs","sm","INIT_STATE","userListReducer","createReducer","selectedUserReducer","combineReducers","middlewares","logger","thunk","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","store","createStore","rootReducer","applyMiddleware","darkTheme","createMuiTheme","palette","ReactDOM","render","ThemeProvider","CssBaseline","document","getElementById"],"mappings":"uiBAoK+D,qBAAXA,SAA0BA,OAAOC,WAAaD,OAAOC,SAAWD,OAAO,qBA6DvD,qBAAXA,SAA0BA,OAAOE,gBAAkBF,OAAOE,cAAgBF,OAAO,0BC/NnI,I,MCFDG,EAAO,aAGAC,EAAY,qBCAnBC,EAAkB,CACtBC,qBADsB,EAEtBC,cAFsB,EAGtBC,gBAHsB,EAItBC,oBAJsB,GAKtBC,iBAAkB,mBAAU,IAAIC,MAAM,mBAAmBC,EAAvC,U,EAGa,SAAC,EAAD,qBAC/BC,MAD+B,YAE/BC,MAF+B,YAG/BC,MAH+B,oBAIV,IAYrB,EAZqB,qBA+BdC,GA/Bc,GACrB,YACEV,EADF,uBAEEC,EAFF,gBAGEC,EAHF,kBAIEC,EAJF,sBAKEC,EALF,mBAUIM,OAAJ,EAEAC,EAASX,KAbY,MHgjBhB,SAA0BY,EAAMC,GACtC,IACC,IAAIC,EAASF,IACZ,MAAOG,GACR,OAAOF,GAAU,EAAME,GAExB,OAAID,GAAUA,EAAOE,KACbF,EAAOE,KAAKH,EAAUI,KAAK,MAAM,GAAQJ,EAAUI,KAAK,MAAM,IAE/DJ,GAAU,EAAOC,GGzjBF,oBHmiBhB,SAAgBF,EAAMM,GAC5B,IACC,IAAIJ,EAASF,IACZ,MAAMG,GACP,OAAOG,EAAQH,GAEhB,OAAID,GAAUA,EAAOE,KACbF,EAAOE,UAAK,EAAQE,GAErBJ,EG5iBe,aAcjB,uBACiBP,KADjB,uDF3ByB,SAAH,8BAAiBD,cAEtCa,UAFsCb,uBAGjCc,wBAHgB,MAIlBd,EAJkB,OAIEA,EAJF,2CEgCDe,CALrB,oCAOFC,IAPE,iCAOsCX,EAASH,EAC/Ce,MARA,0CAEGjB,EAFH,0BAGYF,EAHZ,sBAGA,WAHA,wCAdiB,YAyBnBM,IACAc,iBACAb,EAASV,EAATU,UA3BmB,iBA6BnBA,EAAST,KA7BU,sEAJU,qC,eCV1BuB,EAAwBN,UAAxBM,aAAcC,EAAUP,UAAVO,OACMC,EAAqBP,YAAzCQ,YAAcC,KAGRC,GAAuB,mBACjCJ,EAASC,GADwB,cAEjCF,EAAeE,GAFkB,GCLvBI,EAAyB,SAAAC,GAAY,OAAIA,EAAY,WAC5D,IAAIC,gBAAgBD,IAAkB,ICEtCE,EAAc,UFCa,8CEDb,UAEPC,EAAW,eACtBH,EADsB,uDACP,GADO,6BAEnB,sBAAAI,EAAA,+EAAYC,MAAM,GAAD,OACjBH,GADiB,OACAH,EAAuBC,IAC3C,CACEM,QAASR,KAHR,4CAOQS,EAAc,SACzBC,GADyB,IAEzBR,EAFyB,uDAEV,GAFU,6BAGtB,sBAAAI,EAAA,+EAAYC,MAAM,GAAD,OACjBH,EADiB,YACCM,GADD,OACMT,EAAuBC,IACjD,CACEM,QAASR,KAHR,4CCZQW,EAAmB,SAAAC,GAAI,MAAK,CACvCC,KAJiC,sBAKjCD,S,kECDWE,EAAkB,SAAAC,GAAI,MAAK,CACtCF,KAJ+B,oBAK/BE,SCHWC,EAAe,SAAC,GAEtB,IAAD,IADJD,YACI,MADG,GACH,EACElC,EAAWoC,cAEfC,EAIEH,EAJFG,OACAC,EAGEJ,EAHFI,SACAC,EAEEL,EAFFK,MACAV,EACEK,EADFL,GAQF,OAAO,kBAACW,EAAA,EAAD,KACL,kBAACC,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,CACEC,IAAKL,EACLM,IAAKP,KAGT,kBAACQ,EAAA,EAAD,CACEC,QAAS,kBAACC,EAAA,EAAD,CACPC,KAAM,GACNC,QAfU,SAAApB,GAAE,OAAI,SAAAqB,GACpBA,EAAGC,iBACHnD,EDH6B,SAAA6B,GAAE,8CAAI,WAAM7B,GAAN,SAAAyB,EAAA,+EACrCzB,EACEoD,EACExB,EAAYC,GACZI,KAJiC,2CAAJ,sDCGtBoB,CAAkBxB,KAadoB,CAAQpB,IACfS,GACJgB,UAAW,kBAACC,EAAA,EAAD,CACTC,UAAW,OACXC,QAAS,SAERlB,OC/BImB,EAAW,WACtB,IAAM1D,EAAWoC,cAEfuB,EACEC,aACF,kBAAmB,CAAED,SAArB,EAAGA,aAFHA,SAcF,OATAE,qBAAU,WACR7D,EHDyB,eAC3BqB,EAD2B,uDACZ,GADY,8CAExB,WAAMrB,GAAN,SAAAyB,EAAA,+EACHzB,EACEoD,EACE5B,EAASH,GACTS,KAJD,2CAFwB,sDGEvBgC,CAAc,CACZC,EAAG,EACHC,EAAG,QAGN,KAEY,OAARL,QAAQ,IAARA,OAAA,EAAAA,EAAUM,QACf,kBAACC,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,KAEIR,EAASS,KACP,SAAClC,EAAMmC,GAAP,OAAe,kBAAC,EAAD,CACbA,MACAnC,cAMV,kBAACqB,EAAA,EAAD,0B,gFCjBEe,EAAe,WACnB,IAAMtE,EAAWoC,cACjB,EAaIwB,aACF,kBAAqB,CACnBW,aADF,EAAEA,iBAbFA,aACE1C,EAFJ,EAEIA,GACAQ,EAHJ,EAGIA,OACAE,EAJJ,EAIIA,MACAD,EALJ,EAKIA,SACAkC,EANJ,EAMIA,UACAC,EAPJ,EAOIA,cACAC,EARJ,EAQIA,aACAC,EATJ,EASIA,KACAC,EAVJ,EAUIA,MACAC,EAXJ,EAWIA,IAoBJ,OAAOhD,EAAK,kBAACiD,EAAA,EAAD,KACV,kBAACC,EAAA,EAAD,CACE1C,OAAQ,kBAACK,EAAA,EAAD,CACNC,IAAKL,EACLM,IAAKP,IAEP2C,MAAO1C,EACP2C,UAAW,kBAAClC,EAAA,EAAD,CACTC,KAAK,UAAD,OAAWT,IACbA,GACJ2C,OAAQ,kBAACC,EAAA,EAAD,CACN,aAAc,QACdlC,QArBqB,kBACzBjD,EHjCoC,CACtCgC,KARiC,0BG8D3B,kBAAC,IAAD,SAGJ,kBAACoD,EAAA,EAAD,KACE,kBAAC7B,EAAA,EAAD,CACEC,UAAW,UADb,QAGA,kBAACD,EAAA,EAAD,KA3BiB,SAAA8B,GACnB,IAAMC,EAAWC,KAAKC,MAAQH,EACxBI,EAAU,IAAIF,KAAKD,GACzB,OAAOI,KAAKC,IAAIF,EAAQG,iBAAmB,MAyBrCC,CAAa,IAAIN,KAAKf,KAC1B,kBAACjB,EAAA,EAAD,CACEC,UAAW,SACXsC,WAAY,QAFd,YAIA,kBAACvC,EAAA,EAAD,KAvCoB,UAASkB,EAAT,YAA0BC,IA0C9C,kBAACnB,EAAA,EAAD,KAzCoB,UAASoB,EAAT,YAAiBC,EAAjB,YAA0BC,MA8ClD,kBAACtB,EAAA,EAAD,iCAGIwC,EAAeC,aAAW,SAAAC,GAAK,MAAK,CACxCC,KAAM,CACJC,OAAQF,EAAMG,QAAQ,QAyBXC,EArBH,WACV,IAAMC,EAAUP,IAChB,OAAO,kBAACQ,EAAA,EAAD,CACLC,UAAWF,EAAQJ,MAEnB,kBAACO,EAAA,EAAD,CAAMC,WAAS,EAACN,QAAS,GACvB,kBAACK,EAAA,EAAD,CAAME,MAAI,EAACC,GAAI,IACb,kBAACrD,EAAA,EAAD,CACEE,QAAS,MADX,iBAIF,kBAACgD,EAAA,EAAD,CAAME,MAAI,EAACE,GAAI,EAAGD,GAAI,IACpB,kBAAC,EAAD,OAEF,kBAACH,EAAA,EAAD,CAAME,MAAI,EAACE,GAAI,EAAGD,GAAI,IACpB,kBAAC,EAAD,U,2BC5GFE,GAAa,GAENC,GAAkBC,yBAAcF,IAAD,mBLHT,uBKIV,SAACnD,EAAD,YAAY5B,QADO,cLFb,mBKIV,2BAAU+E,OAFa,I,SCFtCA,GAAa,GAENG,GAAsBD,yBAAc,gBAC3CF,KAD0C,iBAAC,ELFhB,qBKKR,SAACvC,EAAD,OAAgBrC,EAAhB,EAAgBA,KAAhB,uBAChBA,MAJuC,YAAC,ELDd,uBKOR,kCAClB4E,OAPuC,ICDjCI,gBAAgB,CAC7BvD,SAAUoD,GACVxC,aAAc0C,K,SCDVE,GAAc,C,QAACC,EAAQC,MACvBC,GAAmBC,OAAOC,sCAAwCC,KAOzDC,GANDC,aACZC,GACA,GACAN,GAAiBO,KAAe,WAAf,EAAmBV,M,6BCDhCW,GAAYC,aAAe,CAC/BC,QAAS,CACPhG,KAAM,UAIViG,IAASC,OACP,kBAAC,IAAD,CAAeR,UACb,kBAACS,GAAA,EAAD,CAAelC,MAAO6B,IACpB,kBAACM,GAAA,EAAD,KACE,kBAAC,EAAD,SAINC,SAASC,eAAe,W","file":"static/js/main.3fcb9e5c.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {Headers, MimeTypes} from 'http-headers-js'\n\nexport const getResponseBody = async resp => resp\n  .headers\n  .get(Headers.CONTENT_TYPE)\n  .includes(MimeTypes.Application.JSON) ?\n    await resp.json() : await resp.text()\n","const noop = () => {}\nexport default noop\n\nexport const noopThunk = () => noop\n\nexport const noopAction = () => ({type: 'NOOP'})\n","import {getResponseBody} from './util/get-response-body.util'\nimport noop, { noopThunk } from './util/noop.util'\n\nconst DEFAULT_OPTIONS = {\n  onServiceStartAction: noopThunk,\n  onErrorAction: noopThunk,\n  onFinallyAction: noopThunk,\n  responseBodyDataKey: '',\n  generateReqError: (resp) => new Error(`Request failed: ${resp.status}`)\n}\n\nexport const serviceDispatcher = (\n  serviceMethodThunk = noop,\n  resultAction = noop,\n  options = {}\n) => async dispatch => {\n  const {\n    onServiceStartAction,\n    onErrorAction,\n    onFinallyAction,\n    responseBodyDataKey,\n    generateReqError\n  } = {\n    ...DEFAULT_OPTIONS,\n    ...options\n  }\n  let error = undefined\n  let setStatePromise\n  dispatch(onServiceStartAction())\n  try {\n    const resp = await serviceMethodThunk()\n    if (!resp.ok) {\n      throw await generateReqError(resp)\n    }\n    const respBody = await getResponseBody(resp)\n\n    setStatePromise = resultAction && await dispatch(resultAction(\n      respBody[responseBodyDataKey] || respBody\n    ))\n  } catch (err) {\n    error = err\n    console.error(err)\n    dispatch(onErrorAction(err))\n  } finally {\n    dispatch(onFinallyAction())\n  }\n  return error || setStatePromise\n}\n\nexport default serviceDispatcher\n","import {Headers, MimeTypes} from 'http-headers-js'\nconst {CONTENT_TYPE, ACCEPT} = Headers\nconst {Application: {JSON: APPLICATION_JSON}} = MimeTypes\n\nexport const SERVICES_BASE_URI = 'https://60cbec2a21337e0017e45845.mockapi.io'\nexport const DEFAULT_SERVICE_HEADERS = {\n  [ACCEPT]: APPLICATION_JSON,\n  [CONTENT_TYPE]: APPLICATION_JSON,\n}\n","export const generateUrlQueryString = searchParams => searchParams ?\n  `?${new URLSearchParams(searchParams)}` : \"\";\n","import { DEFAULT_SERVICE_HEADERS, SERVICES_BASE_URI } from \"./services.config\";\nimport { generateUrlQueryString } from \"./generate-url-query-string.util\";\n\nconst serviceBaseUri = `${SERVICES_BASE_URI}/users`\n\nexport const getUsers = (\n  searchParams = {}\n) => async () => fetch(\n  `${serviceBaseUri}${generateUrlQueryString(searchParams)}`,\n  {\n    headers: DEFAULT_SERVICE_HEADERS\n  }\n)\n\nexport const getUserById = (\n  id,\n  searchParams = {}\n) => async () => fetch(\n  `${serviceBaseUri}/${id}${generateUrlQueryString(searchParams)}`,\n  {\n    headers: DEFAULT_SERVICE_HEADERS\n  }\n)\n","import serviceDispatcher from 'redux-thunk-service-dispatcher'\nimport { getUsers } from '../../services/users.service'\nexport const USER_LIST_SET_STATE = 'USER_LIST_SET_STATE'\nexport const USER_LIST_RESET = 'USER_LIST_RESET'\n\nexport const userListSetState = list => ({\n  type: USER_LIST_SET_STATE,\n  list\n})\n\nexport const userListResetState = () => ({\n  type: USER_LIST_RESET\n})\n\nexport const fetchUserList = (\n  searchParams = {}\n) => async dispatch =>\n  dispatch(\n    serviceDispatcher(\n      getUsers(searchParams),\n      userListSetState\n    )\n  )\n","import serviceDispatcher from 'redux-thunk-service-dispatcher'\nimport { getUserById } from '../../services/users.service'\n\nexport const SELECTED_USER_SET = 'SELECTED_USER_SET'\nexport const SELECTED_USER_CLEAR = 'SELECTED_USER_CLEAR'\n\nexport const setSelectedUser = user => ({\n  type: SELECTED_USER_SET,\n  user\n})\n\nexport const clearSelectedUser = () => ({\n  type: SELECTED_USER_CLEAR\n})\n\nexport const fetchSelectedUser = id => async dispatch =>\n  dispatch(\n    serviceDispatcher(\n      getUserById(id),\n      setSelectedUser\n    )\n  )\n","import { Avatar, Link, ListItem, ListItemAvatar, ListItemText, Typography } from '@material-ui/core'\nimport React from 'react'\nimport { useDispatch } from 'react-redux'\nimport { fetchSelectedUser } from '../store/actions/selected-user.actions'\n\nexport const UserListItem = ({\n  user = {}\n}) => {\n  const dispatch = useDispatch()\n  const {\n    avatar,\n    fullName,\n    email,\n    id\n  } = user\n\n  const onClick = id => ev => {\n    ev.preventDefault()\n    dispatch(fetchSelectedUser(id))\n  }\n\n  return <ListItem {...{}}>\n    <ListItemAvatar {...{}}>\n      <Avatar {...{\n        alt: fullName,\n        src: avatar\n      }} />\n    </ListItemAvatar>\n    <ListItemText {...{\n      primary: <Link {...{\n        href: '',\n        onClick: onClick(id)\n      }}>{fullName}</Link>,\n      secondary: <Typography {...{\n        component: 'span',\n        variant: 'body2'\n      }}>\n        {email}\n      </Typography>\n    }} />\n  </ListItem>\n}\n","import { useDispatch, useSelector } from 'react-redux'\nimport React, { useEffect } from 'react'\nimport { fetchUserList } from '../store/actions/user-list.actions'\nimport { List, Paper, Typography } from '@material-ui/core'\nimport { UserListItem } from './UserListItem.component'\n\nexport const UserList = () => {\n  const dispatch = useDispatch()\n  const {\n    userList\n  } = useSelector(\n    ({ userList }) => ({ userList })\n  )\n\n  useEffect(() => {\n    dispatch(\n      fetchUserList({\n        p: 1,\n        l: 10\n      })\n    )\n  }, [])\n\n  return userList?.length ?\n    <Paper>\n      <List {...{}}>\n        {\n          userList.map(\n            (user, key) => <UserListItem {...{\n              key,\n              user\n            }} />\n          )\n        }\n      </List>\n    </Paper> :\n    <Typography>Loading users...</Typography>\n}\n","import React from 'react'\nimport 'redux-thunk-service-dispatcher/dist/index.css'\nimport { UserList } from './components/UserList.component'\nimport {\n  Avatar,\n  Box,\n  Card,\n  CardContent,\n  CardHeader,\n  Grid,\n  IconButton,\n  Link,\n  makeStyles,\n  Typography\n} from '@material-ui/core'\nimport CloseIcon from '@material-ui/icons/Close'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { clearSelectedUser } from './store/actions/selected-user.actions'\n\nconst SelectedUser = () => {\n  const dispatch = useDispatch()\n  const {\n    selectedUser: {\n      id,\n      avatar,\n      email,\n      fullName,\n      birthDate,\n      streetAddress,\n      streetSuffix,\n      city,\n      state,\n      zip,\n    }\n  } = useSelector(\n    ({selectedUser}) => ({\n      selectedUser\n    })\n  )\n\n  const getAddressLine1 = () => `${streetAddress} ${streetSuffix}`\n  const getAddressLine2 = () => `${city} ${state} ${zip}`\n\n  const handleCloseOnClick = () =>\n    dispatch(clearSelectedUser())\n\n  const calculateAge = birthday => {\n    const ageDifMs = Date.now() - birthday\n    const ageDate = new Date(ageDifMs)\n    return Math.abs(ageDate.getUTCFullYear() - 1970)\n  }\n\n  return id ? <Card>\n    <CardHeader {...{\n      avatar: <Avatar {...{\n        alt: fullName,\n        src: avatar\n      }} />,\n      title: fullName,\n      subheader: <Link {...{\n        href:`mailto:${email}`\n      }}>{email}</Link>,\n      action: <IconButton {...{\n        'aria-label': 'close',\n        onClick: handleCloseOnClick\n      }}>\n        <CloseIcon />\n      </IconButton>\n    }} />\n    <CardContent>\n      <Typography {...{\n        component: 'strong'\n      }}>Age:</Typography>\n      <Typography {...{\n      }}>{calculateAge(new Date(birthDate))}</Typography>\n      <Typography {...{\n        component: 'strong',\n        fontWeight: 'bold'\n      }}>Address:</Typography>\n      <Typography>\n        {getAddressLine1()}\n      </Typography>\n      <Typography>\n        {getAddressLine2()}\n      </Typography>\n    </CardContent>\n  </Card> :\n  <Typography>Please select a user...</Typography>\n}\n\nconst useAppStyles = makeStyles(theme => ({\n  root: {\n    margin: theme.spacing(2)\n  }\n}))\n\nconst App = () => {\n  const classes = useAppStyles()\n  return <Box {...{\n    className: classes.root\n  }}>\n    <Grid container spacing={2}>\n      <Grid item xs={12}>\n        <Typography {...{\n          variant: 'h5'\n        }}>Basic Usage:</Typography>\n      </Grid>\n      <Grid item sm={6} xs={12}>\n        <UserList />\n      </Grid>\n      <Grid item sm={6} xs={12}>\n        <SelectedUser />\n      </Grid>\n    </Grid>\n  </Box>\n}\n\nexport default App\n","import {createReducer} from \"redux-create-reducer\"\nimport { USER_LIST_RESET, USER_LIST_SET_STATE } from '../actions/user-list.actions'\n\nconst INIT_STATE = []\n\nexport const userListReducer = createReducer(INIT_STATE,{\n  [USER_LIST_SET_STATE]: (userList, {list}) => list,\n  [USER_LIST_RESET]: () => [...INIT_STATE]\n})\n","import { createReducer } from 'redux-create-reducer'\nimport { SELECTED_USER_CLEAR, SELECTED_USER_SET } from '../actions/selected-user.actions'\n\nconst INIT_STATE = {}\n\nexport const selectedUserReducer = createReducer(\n  {...INIT_STATE},\n  {\n    [SELECTED_USER_SET]: (selectedUser, {user}) => ({\n      ...user\n    }),\n    [SELECTED_USER_CLEAR]: () => ({\n      ...INIT_STATE\n    })\n  }\n)\n","import { combineReducers } from 'redux'\nimport { userListReducer } from './user-list.reducer'\nimport { selectedUserReducer } from './selected-user.reducer'\n\nexport default combineReducers({\n  userList: userListReducer,\n  selectedUser: selectedUserReducer\n})\n","import thunk from 'redux-thunk'\nimport { applyMiddleware, compose, createStore } from 'redux'\nimport rootReducer from './reducers/root.reducer'\nimport logger from 'redux-logger'\n\nconst middlewares = [logger, thunk]\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose\nconst store = createStore(\n  rootReducer,\n  {},\n  composeEnhancers(applyMiddleware(...middlewares))\n)\n\nexport default store\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport { Provider } from 'react-redux'\nimport store from './store'\nimport { createMuiTheme, CssBaseline, ThemeProvider } from '@material-ui/core'\n\nconst darkTheme = createMuiTheme({\n  palette: {\n    type: 'dark',\n  },\n})\n\nReactDOM.render(\n  <Provider {...{store}}>\n    <ThemeProvider theme={darkTheme} >\n      <CssBaseline>\n        <App />\n      </CssBaseline>\n    </ThemeProvider>\n  </Provider>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}